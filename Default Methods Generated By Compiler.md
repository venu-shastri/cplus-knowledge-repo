

# Default Methods Generated By Compiler

Each class comprises four implicitly defined default methods, which you can replace with your own definitions:

- The `default constructor and the destructor`
- The `copy constructor and the standard assignment`

## Copy Constructor

- existing object can be used to initialize a new object
- If a class does not contain a copy constructor, the compiler will automatically create a minimal version, known as the standard copy constructor.
- constructor copies the data members of the object passed to it to corresponding data members of the new object

```
Prototype: ClassName( const ClassName& );
```

- Initializing With new Object

```
Example: ClassName newObjectRefernce(exisistingObjectReference);
```

```C++
#include <iostream>
using namespace std;
class FloatArr
{
private:
	float* arrPtr; // Dynamic member
	int max; // Maximum quantity without
	// reallocation of new storage.
	int cnt; // Number of array elements
public:
	FloatArr(int n = 256); // Constructor
	FloatArr(int n, float val);
	~FloatArr(); // Destructor
	int length() const { return cnt; }
	float& operator[](int i); // Subscript operator.
	float operator[](int i) const;
	bool append(float val); // Append value val.
	bool remove(int pos); // Delete position pos.
};

FloatArr::FloatArr(int n)
{
	max = n; cnt = 0;
	arrPtr = new float[max];
}
FloatArr::FloatArr(int n, float val)
{
	max = cnt = n;
	arrPtr = new float[max];
	for (int i = 0; i < cnt; ++i)
		arrPtr[i] = val;
}

float& FloatArr::operator[](int i)
{
	if (i < 0 || i >= cnt) // Range checking
	{
		cerr << "\n class FloatArr: Out of range! ";
		exit(1);
	}
	return arrPtr[i];
}
float FloatArr::operator[](int i) const
{
	// Operator Overloading Code
}
bool FloatArr::append(float val)
{
	if (cnt < max)
	{
		arrPtr[cnt++] = val; return true;
	}
	else // Enlarge the array!
		return false;
}
bool FloatArr::remove(int pos)
{
	if (pos >= 0 && pos < cnt)
	{
		for (int i = pos; i < cnt - 1; ++i)
			arrPtr[i] = arrPtr[i + 1];
		--cnt;
		return true;
	}
	else
		return false;
}
FloatArr::~FloatArr()
{
	delete[] arrPtr;
}

int main()
{
	FloatArr v(10); // Array v of 10 float values
	FloatArr w(20, 1.0F); // To initialize array w of 20 float values with 1.0.
	FloatArr x(v); //standard Copy Constructor Called
	v.append(0.5F);
	cout << " Current number of elements in v: "
		<< v.length() << endl; // 1
	cout << " Current number of elements in w: "
		<< w.length() << endl; // 20
	return 0;
}
```

![image-20230330055322878](standardCopyConstructor)

```C++
A standard copy constructor is normally sufficient for a class. However, simply copying the data members would serve no useful purpose for objects containing dynamic members(neighbours). This would merely copy the pointers, meaning that the pointers of several different objects would reference the same place in memory

This scenario would obviously mean trouble. Imagine releasing memory allocated for an object dynamically. The pointer for the second object would reference a memory area that no longer existed
```



#### Proprietary Version of the Copy Constructor

----

- For classes with dynamic members(neighbours), create a new copy constructor  to implement deep cloning.

#### Default Assignment

---

Given that v1 and v2 are two FloatArr class objects, the following assignment is valid:
**Example:  v1 = v2;**

```
However, this technique is not suitable for classes with dynamic members. This would simply point the pointers belonging to different objects at the same dynamic allocated memory. In addition, memory previously addressed by a pointer of the target object will be unreferenced after the assignment.
```

#### Overloading the Assignment Operator

---

- The operator function for the assignment must perform the following tasks:

- Release the memory referenced by the dynamic members

- Allocate sufficient memory and copy the source objectâ€™s data to that memory.

- The operator function is implemented as a class method and returns a reference to the target object allowing multiple assignments

- The prototype of the operator function for the FloatArr class is thus defined as follows:

  

```C++
FloatArr& FloatArr::operator=( const FloatArr& src)
```

Note;

> When implementing the operator function you must avoid self assignment, which would read memory areas that have already been released.



#### Complete Example

---

```C++
#include <iostream>
using namespace std;
class FloatArr
{
private:
	float* arrPtr; // Dynamic member
	int max; // Maximum quantity without
	// reallocation of new storage.
	int cnt; // Number of array elements
public:
	FloatArr(int n = 256); // Constructor
	FloatArr(int n, float val);
	~FloatArr(); // Destructor
	FloatArr(const FloatArr& src); // Copy constructor
	FloatArr& operator=(const FloatArr&); // Assignment
	int length() const { return cnt; }
	float& operator[](int i); // Subscript operator.
	float operator[](int i) const;
	bool append(float val); // Append value val.
	bool remove(int pos); // Delete position pos.
};

FloatArr::FloatArr(int n)
{
	max = n; cnt = 0;
	arrPtr = new float[max];
}
FloatArr::FloatArr(int n, float val)
{
	max = cnt = n;
	arrPtr = new float[max];
	for (int i = 0; i < cnt; ++i)
		arrPtr[i] = val;
}
FloatArr::FloatArr(const FloatArr& src)
{
	max = src.max; cnt = src.cnt;
	arrPtr = new float[max];
	for (int i = 0; i < cnt; i++)
		arrPtr[i] = src.arrPtr[i];
}
FloatArr& FloatArr::operator=(const FloatArr& src)
{
	if (this != &src) // No self assignments!
	{
		max = src.max;
		cnt = src.cnt;
		delete[] arrPtr; // Release memory,
		arrPtr = new float[max]; // reallocate and
		for (int i = 0; i < cnt; i++) // copy elements.
			arrPtr[i] = src.arrPtr[i];
	}
	return *this;
}

float& FloatArr::operator[](int i)
{
	if (i < 0 || i >= cnt) // Range checking
	{
		cerr << "\n class FloatArr: Out of range! ";
		exit(1);
	}
	return arrPtr[i];
}
float FloatArr::operator[](int i) const
{
	// Operator Overloading Code
}
bool FloatArr::append(float val)
{
	if (cnt < max)
	{
		arrPtr[cnt++] = val; return true;
	}
	else // Enlarge the array!
		return false;
}
bool FloatArr::remove(int pos)
{
	if (pos >= 0 && pos < cnt)
	{
		for (int i = pos; i < cnt - 1; ++i)
			arrPtr[i] = arrPtr[i + 1];
		--cnt;
		return true;
	}
	else
		return false;
}
FloatArr::~FloatArr()
{
	delete[] arrPtr;
}

int main()
{
	FloatArr v(10); // Array v of 10 float values
	FloatArr w(20, 1.0F); // To initialize array w of 20 float values with 1.0.
	const FloatArr kw(w); // Copy Constructor Called
	v = w; //Assignment Operator Callled
	v.append(0.5F);
	cout << " Current number of elements in v: "
		<< v.length() << endl; // 1
	cout << " Current number of elements in w: "
		<< w.length() << endl; // 20
	return 0;
}
```

